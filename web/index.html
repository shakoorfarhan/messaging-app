<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Go Messaging App</title>
  <style>
    :root {
      --ink: #0f172a;
      --muted: #475569;
      --accent: #0ea5e9;
      --accent-2: #10b981;
      --border: #e2e8f0;
      --bg: #f8fafc;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Helvetica Neue", Arial, sans-serif;
      background: radial-gradient(circle at 20% 20%, #eef2ff, transparent 25%), var(--bg);
      color: var(--ink);
      min-height: 100vh;
      padding: 24px;
    }
    h1 { margin: 0; }
    .main { max-width: 1100px; margin: 0 auto; }
    .topbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 8px;
    }
    .tagline { color: var(--muted); }
    .grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      align-items: start;
    }
    .card {
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 8px 30px rgba(15, 23, 42, 0.05);
    }
    label {
      display: block;
      font-size: 14px;
      margin-bottom: 4px;
      color: var(--muted);
    }
    input, textarea {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 14px;
      margin-bottom: 10px;
      background: #f8fafc;
    }
    button {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 10px 14px;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
    }
    button.secondary { background: var(--accent-2); }
    button.danger { background: #ef4444; }
    button.ghost {
      background: transparent;
      color: var(--ink);
      border: 1px solid var(--border);
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .stack { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .pill {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 999px;
      background: #ecfeff;
      color: #0f172a;
      border: 1px solid var(--border);
      font-size: 12px;
    }
    ul { list-style: none; padding: 0; margin: 0; }
    li { border-bottom: 1px solid var(--border); padding: 10px 0; }
    .time { font-size: 12px; color: var(--muted); }
    .status { margin: 12px 0; font-size: 14px; color: var(--muted); }
    .auth-layout { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 18px; margin-top: 16px; align-items: start; }
    .hero {
      background: linear-gradient(135deg, rgba(14,165,233,0.12), rgba(16,185,129,0.12));
      border: 1px dashed var(--border);
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding-bottom: 18px;
    }
    .tabs { margin-bottom: 12px; }
    .tab {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #fff;
      cursor: pointer;
      color: var(--muted);
    }
    .tab.active {
      background: #0ea5e9;
      color: #fff;
      border-color: #0ea5e9;
    }
    .layout {
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 16px;
      align-items: start;
    }
    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; }
      .chat-window { height: 70vh; }
    }
    .chat-window {
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 8px 30px rgba(15, 23, 42, 0.05);
      display: flex;
      flex-direction: column;
      gap: 12px;
      height: clamp(420px, 70vh, 580px);
    }
    .chat-stream {
      flex: 1;
      overflow-y: auto;
      padding-right: 4px;
    }
    .bubble {
      max-width: 70%;
      padding: 10px 12px;
      border-radius: 12px;
      margin-bottom: 10px;
      border: 1px solid var(--border);
      background: #f1f5f9;
    }
    .bubble.me {
      margin-left: auto;
      background: #dcfce7;
      border-color: #bbf7d0;
    }
    .bubble .meta { font-size: 12px; color: var(--muted); margin-top: 4px; }
    .invite-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      background: #fff;
      box-shadow: 0 4px 20px rgba(15, 23, 42, 0.04);
    }
    .conversations {
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 8px 30px rgba(15, 23, 42, 0.05);
      padding: 10px;
      display: grid;
      gap: 8px;
      max-height: 280px;
      overflow-y: auto;
    }
    .conversation {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      border-radius: 10px;
      cursor: pointer;
      border: 1px solid transparent;
    }
    .conversation:hover { background: #f8fafc; border-color: var(--border); }
    .conversation.active { background: #e0f2fe; border-color: #0ea5e9; }
    .badge {
      background: #ef4444;
      color: #fff;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 12px;
    }
    .composer {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-top: auto;
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script type="module">
    const { useEffect, useReducer, useRef } = React;

    const fetchJSON = async (url, options = {}) => {
      const res = await fetch(url, {
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        ...options,
      });
      let message = '';
      try {
        const data = await res.json();
        message = data.message || '';
        if (!res.ok) throw new Error(message || 'request failed');
        return { ok: true, data, message };
      } catch (err) {
        if (!message) {
          try {
            const text = await res.text();
            message = text || err.message;
          } catch {
            message = err.message;
          }
        }
        return { ok: false, error: message || 'request failed' };
      }
    };

    const initialState = {
      status: 'Ready.',
      profile: null,
      messages: [],
      authForm: { username: '', password: '' },
      registerForm: { username: '', password: '', location: '', university: '', public: true },
      messageForm: { to: '', body: '' },
      authMode: 'login',
      suggestions: [],
      invites: [],
      conversations: [],
      activeChat: '',
      lastSeen: {},
    };

    function reducer(state, action) {
      switch (action.type) {
        case 'SET':
          return { ...state, [action.key]: action.value };
        default:
          return state;
      }
    }

    function App() {
      const [state, dispatch] = useReducer(reducer, initialState);
      const {
        status,
        profile,
        messages,
        authForm,
        registerForm,
        messageForm,
        authMode,
        suggestions,
        invites,
        conversations,
        activeChat,
        lastSeen,
      } = state;
      const lastSeenRef = useRef({});
      const messageInputRef = useRef(null);
      const chatStreamRef = useRef(null);
      const convoListRef = useRef(null);
      const lastMsgCountRef = useRef(0);
      const lastChatRef = useRef('');
      const convoFirstRef = useRef('');
      const convoLengthRef = useRef(0);
      const chatCountRef = useRef({});

      const scrollToBottom = () => {
        if (chatStreamRef.current) {
          chatStreamRef.current.scrollTop = chatStreamRef.current.scrollHeight;
        }
      };

      const setField = (key, value) => dispatch({ type: 'SET', key, value });

      useEffect(() => {
        const stored = localStorage.getItem('lastSeen');
        if (stored) {
          try {
            const parsed = JSON.parse(stored);
            setField('lastSeen', parsed);
            lastSeenRef.current = parsed;
          } catch (_) {}
        }
      }, []);

      const loadProfile = async () => {
        const res = await fetch('/api/profile', { credentials: 'include' });
        if (res.ok) {
          const data = await res.json();
          setField('profile', data);
        } else {
          setField('profile', null);
          setField('messages', []);
          setField('invites', []);
          setField('conversations', []);
          setField('lastSeen', {});
          lastSeenRef.current = {};
        }
      };

      const loadMessages = async () => {
        const res = await fetch('/api/messages', { credentials: 'include' });
        if (!res.ok) {
          setField('messages', []);
          if (res.status === 401) setField('profile', null);
          return;
        }
        const data = await res.json();
        const list = Array.isArray(data) ? data : [];
        setField('messages', list);
        computeConversations(list, lastSeenRef.current);
        if (activeChat) {
          markSeen(activeChat, list);
        }
      };

      useEffect(() => {
        const id = setInterval(() => {
          if (profile) {
            loadMessages();
            loadInvitations();
          }
        }, 1000);
        return () => clearInterval(id);
      }, [profile]);

      const loadInvitations = async () => {
        const res = await fetch('/api/invitations', { credentials: 'include' });
        if (!res.ok) {
          setField('invites', []);
          if (res.status === 401) setField('profile', null);
          return;
        }
        const data = await res.json();
        setField('invites', Array.isArray(data) ? data : []);
      };

      useEffect(() => {
        loadProfile();
        loadMessages();
        loadInvitations();
      }, []);

      useEffect(() => {
        if (activeChat) {
          markSeen(activeChat, messages);
        }
      }, [activeChat]);

      useEffect(() => {
        if (!activeChat) {
          lastMsgCountRef.current = (messages || []).length;
          lastChatRef.current = activeChat;
          return;
        }
        const total = (messages || []).length;
        const activeCount = (messages || []).filter((m) => m.from === activeChat || m.to === activeChat).length;
        const prevActive = chatCountRef.current[activeChat] || 0;
        const chatChanged = activeChat !== lastChatRef.current;
        const hasNewInActive = activeCount > prevActive;
        if (chatChanged || hasNewInActive) {
          if (messageInputRef.current) {
            messageInputRef.current.focus();
          }
          scrollToBottom();
        }
        chatCountRef.current = { ...chatCountRef.current, [activeChat]: activeCount };
        lastMsgCountRef.current = total;
        lastChatRef.current = activeChat;
      }, [messages, activeChat]);

      const handleRegister = async (e) => {
        e.preventDefault();
        const { ok, error } = await fetchJSON('/api/register', {
          method: 'POST',
          body: JSON.stringify(registerForm),
        });
        setField('status', ok ? 'Registered! Now log in.' : error);
        if (ok) setField('authMode', 'login');
      };

      const handleLogin = async (e) => {
        e.preventDefault();
        const { ok, error } = await fetchJSON('/api/login', {
          method: 'POST',
          body: JSON.stringify(authForm),
        });
        if (ok) {
          setField('status', 'Logged in.');
          setField('authForm', { username: '', password: '' });
          await loadProfile();
          await loadMessages();
          await loadInvitations();
          setField('lastSeen', {});
          lastSeenRef.current = {};
          setField('activeChat', '');
        } else {
          setField('status', error);
        }
      };

      const handleLogout = async () => {
        const { ok, error } = await fetchJSON('/api/logout', { method: 'POST' });
        setField('status', ok ? 'Logged out.' : error);
        setField('profile', null);
        setField('messages', []);
        setField('invites', []);
      };

      const handleSend = async (e) => {
        e.preventDefault();
        const target = messageForm.to || activeChat;
        if (!target || !messageForm.body) {
          setField('status', 'Please choose a recipient and enter a message.');
          return;
        }
        const { ok, error, message, data } = await fetchJSON('/api/messages', {
          method: 'POST',
          body: JSON.stringify({ to: target, body: messageForm.body }),
        });
        if (ok) {
          setField('status', message || data?.message || `Sent to ${target}.`);
          setField('messageForm', { to: '', body: '' });
          setField('activeChat', target);
          markSeen(target, messages);
          loadMessages();
        } else {
          setField('status', error);
        }
      };

      const acceptInvite = async (id) => {
        const { ok, error, data } = await fetchJSON('/api/invitations', {
          method: 'POST',
          body: JSON.stringify({ id }),
        });
        if (ok) {
          setField('status', 'Invitation accepted. You can now message each other.');
          setField('invites', (invites || []).filter((inv) => inv.id !== id));
          const chatUser = data?.sender;
          if (chatUser) {
            setField('activeChat', chatUser);
          }
          loadMessages();
          loadInvitations();
        } else {
          setField('status', error);
        }
      };

      const computeConversations = (list, seenOverride) => {
        if (!profile) return;
        const seenMap = seenOverride || lastSeenRef.current;
        const map = new Map();
        list.forEach((m) => {
          const other = m.from === profile.username ? m.to : m.from;
          const existing = map.get(other) || { user: other, last: null, unread: 0 };
          if (!existing.last || new Date(m.sentAt) > new Date(existing.last.sentAt)) {
            existing.last = m;
          }
          const seen = seenMap[other] ? new Date(seenMap[other]) : null;
          if (m.to === profile.username && (!seen || new Date(m.sentAt) > seen)) {
            existing.unread += 1;
          }
          map.set(other, existing);
        });
        const arr = Array.from(map.values()).sort((a, b) => new Date(b.last.sentAt) - new Date(a.last.sentAt));
        setField('conversations', arr);
      };

      const markSeen = (user, list) => {
        if (!user) return;
        const now = new Date().toISOString();
        const updated = { ...lastSeenRef.current, [user]: now };
        setField('lastSeen', updated);
        lastSeenRef.current = updated;
        localStorage.setItem('lastSeen', JSON.stringify(updated));
        computeConversations(list || messages, updated);
      };

      const selectChat = (user) => {
        setField('suggestions', []);
        setField('activeChat', user);
        markSeen(user, messages);
        scrollToBottom();
      };

      useEffect(() => {
        const firstUser = (conversations && conversations[0] && conversations[0].user) || '';
        const changed = firstUser && firstUser !== convoFirstRef.current;
        const grew = (conversations || []).length > convoLengthRef.current;
        if (convoListRef.current && (changed || grew)) {
          convoListRef.current.scrollTop = 0;
        }
        convoFirstRef.current = firstUser;
        convoLengthRef.current = (conversations || []).length;
      }, [conversations]);

      const searchUsers = async (query) => {
        if (!query) {
          setField('suggestions', []);
          return;
        }
        const res = await fetch(`/api/users?search=${encodeURIComponent(query)}`, { credentials: 'include' });
        if (res.ok) {
          const data = await res.json();
          const enriched = data.map((u) => {
            let score = 0;
            if (profile?.university && u.university && profile.university.toLowerCase() === u.university.toLowerCase()) score += 2;
            if (profile?.location && u.location && profile.location.toLowerCase() === u.location.toLowerCase()) score += 1;
            return { ...u, score };
          }).sort((a, b) => b.score - a.score);
          setField('suggestions', enriched);
        }
      };

      const renderAuth = () => (
        React.createElement('div', { className: 'auth-layout' },
          React.createElement('div', { className: 'card hero' },
            React.createElement('h2', null, 'Message peers securely'),
            React.createElement('p', { className: 'tagline' }, 'Register with your location and university, then chat directly. Everything is powered by the Go API you see here.'),
            React.createElement('div', { className: 'stack' },
              React.createElement('span', { className: 'pill' }, 'SPA'),
              React.createElement('span', { className: 'pill' }, 'React'),
              React.createElement('span', { className: 'pill' }, 'Postgres-backed'),
            ),
          ),
          React.createElement('div', { className: 'card' },
            React.createElement('div', { className: 'stack tabs' },
              ['login', 'register'].map((mode) =>
                React.createElement('button', {
                  key: mode,
                  className: `tab ${authMode === mode ? 'active' : ''}`,
                  type: 'button',
                  onClick: () => setField('authMode', mode),
                }, mode === 'login' ? 'Log In' : 'Register')
              ),
            ),
            authMode === 'login' ? (
              React.createElement('form', { onSubmit: handleLogin },
                React.createElement('label', { htmlFor: 'login-username' }, 'Username'),
                React.createElement('input', {
                  id: 'login-username',
                  value: authForm.username,
                  onChange: (e) => setField('authForm', { ...authForm, username: e.target.value }),
                  placeholder: 'piper',
                }),
                React.createElement('label', { htmlFor: 'login-password' }, 'Password'),
                React.createElement('input', {
                  id: 'login-password',
                  type: 'password',
                  value: authForm.password,
                  onChange: (e) => setField('authForm', { ...authForm, password: e.target.value }),
                  placeholder: '••••••••',
                }),
                React.createElement('div', { className: 'stack' },
                  React.createElement('button', { type: 'submit' }, 'Login'),
                ),
              )
            ) : (
              React.createElement('form', { onSubmit: handleRegister },
                React.createElement('label', { htmlFor: 'reg-username' }, 'Username'),
                React.createElement('input', {
                  id: 'reg-username',
                  value: registerForm.username,
                  onChange: (e) => setField('registerForm', { ...registerForm, username: e.target.value }),
                  placeholder: 'piper',
                }),
                React.createElement('label', { htmlFor: 'reg-password' }, 'Password'),
                React.createElement('input', {
                  id: 'reg-password',
                  type: 'password',
                  value: registerForm.password,
                  onChange: (e) => setField('registerForm', { ...registerForm, password: e.target.value }),
                  placeholder: '••••••••',
                }),
                React.createElement('label', { htmlFor: 'reg-location' }, 'Location'),
                React.createElement('input', {
                  id: 'reg-location',
                  value: registerForm.location,
                  onChange: (e) => setField('registerForm', { ...registerForm, location: e.target.value }),
                  placeholder: 'Berlin',
                }),
                React.createElement('label', { htmlFor: 'reg-university' }, 'University'),
                React.createElement('input', {
                  id: 'reg-university',
                  value: registerForm.university,
                  onChange: (e) => setField('registerForm', { ...registerForm, university: e.target.value }),
                  placeholder: 'State University',
                }),
                React.createElement('label', { htmlFor: 'reg-public' }, 'Account visibility'),
                React.createElement('div', { className: 'stack', style: { marginBottom: '10px' } },
                  React.createElement('input', {
                    id: 'reg-public',
                    type: 'checkbox',
                    checked: registerForm.public,
                    onChange: (e) => setField('registerForm', { ...registerForm, public: e.target.checked }),
                  }),
                  React.createElement('span', null, registerForm.public ? 'Public (open messages)' : 'Private (requires invite)'),
                ),
                React.createElement('div', { className: 'stack' },
                  React.createElement('button', { type: 'submit', className: 'secondary' }, 'Create account'),
                ),
              )
            ),
          ),
        )
      );

      const renderDashboard = () => (
        React.createElement('div', { className: 'layout' },
          React.createElement('div', { className: 'card', style: { display: 'flex', flexDirection: 'column', gap: '12px' } },
            React.createElement('h3', null, 'Profile'),
            profile ? (
              React.createElement(React.Fragment, null,
                React.createElement('div', { className: 'stack' },
                  React.createElement('span', { className: 'pill' }, '@', profile.username),
                  React.createElement('span', { className: 'pill' }, profile.location || 'Unknown location'),
                  React.createElement('span', { className: 'pill' }, profile.university || 'No university'),
                  React.createElement('span', { className: 'pill' }, profile.public ? 'Public' : 'Private'),
                ),
                React.createElement('div', { className: 'time' }, 'Joined ', new Date(profile.createdAt).toLocaleString()),
                React.createElement('div', { className: 'stack' },
                  React.createElement('label', { htmlFor: 'toggle-public', style: { margin: 0 } }, 'Visibility'),
                  React.createElement('input', {
                    id: 'toggle-public',
                    type: 'checkbox',
                    checked: profile.public,
                    onChange: async (e) => {
                      const next = e.target.checked;
                      const res = await fetch('/api/profile/update', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ public: next }),
                      });
                      if (res.ok) {
                        setField('profile', { ...profile, public: next });
                        setField('status', `Visibility set to ${next ? 'Public' : 'Private'}`);
                      } else {
                        setField('status', 'Failed to update visibility');
                      }
                    },
                  }),
                  React.createElement('span', null, profile.public ? 'Public' : 'Private'),
                ),
              )
            ) : React.createElement('div', null, 'Not signed in.'),
            React.createElement('div', null,
              React.createElement('div', { className: 'stack', style: { marginBottom: '10px', flexWrap: 'wrap' } },
                React.createElement('input', {
                  id: 'new-chat',
                  value: messageForm.to,
                  onChange: (e) => {
                    const value = e.target.value;
                    setField('activeChat', '');
                    setField('messageForm', { ...messageForm, to: value });
                    searchUsers(value);
                  },
                  placeholder: 'Search to chat or invite (name, uni, location)',
                  style: { flex: 1, minWidth: '220px' },
                }),
              ),
              (suggestions || []).length > 0 && React.createElement('div', { className: 'card', style: { width: '100%', marginBottom: '8px' } },
                React.createElement('div', { className: 'stack', style: { flexWrap: 'wrap', marginBottom: '6px' } },
                  (suggestions || []).map((u) =>
                    React.createElement('button', {
                      key: u.username,
                      type: 'button',
                      className: 'ghost',
                      onClick: () => {
                        setField('activeChat', u.username);
                        setField('messageForm', { to: u.username, body: '' });
                        setField('suggestions', []);
                      },
                    }, `${u.username} ${u.public ? '(public)' : '(private)'}`)
                  )
                )
              ),
              React.createElement('div', { className: 'stack', style: { marginBottom: '8px', justifyContent: 'space-between' } },
                React.createElement('strong', null, 'Chats'),
                React.createElement('div', null)
              ),
              React.createElement('div', { className: 'conversations', ref: convoListRef },
                (conversations || []).length === 0
                  ? React.createElement('div', { className: 'time' }, 'No conversations yet.')
                  : (conversations || []).map((c) =>
                      React.createElement('div', {
                        key: c.user,
                        className: `conversation ${activeChat === c.user ? 'active' : ''}`,
                        onClick: () => selectChat(c.user),
                      },
                        React.createElement('div', null,
                          React.createElement('div', null, c.user),
                          c.last && React.createElement('div', { className: 'time' }, c.last.body.slice(0, 40)),
                        ),
                        React.createElement('div', { className: 'stack' },
                          c.unread > 0 && React.createElement('span', { className: 'badge' }, c.unread),
                          c.last && React.createElement('span', { className: 'time' }, new Date(c.last.sentAt).toLocaleTimeString()),
                        )
                      )
                    )
              ),
              React.createElement('div', { className: 'stack', style: { marginTop: '12px', marginBottom: '8px' } },
                React.createElement('strong', null, 'Invitations'),
                React.createElement('div', null),
              ),
              (invites || []).length === 0
                ? React.createElement('div', null, 'No pending invitations.')
                : React.createElement('div', { style: { display: 'grid', gap: '8px' } },
                    (invites || []).map((inv) =>
                      React.createElement('div', { key: inv.id, className: 'invite-card' },
                        React.createElement('div', null,
                          React.createElement('strong', null, inv.sender),
                          ' wants to connect.',
                        ),
                        React.createElement('div', null, inv.body),
                        React.createElement('div', { className: 'time' }, new Date(inv.createdAt).toLocaleString()),
                        React.createElement('button', { onClick: () => acceptInvite(inv.id), className: 'secondary' }, 'Accept'),
                      )
                    )
                  )
            ),
          ),
          React.createElement('div', { className: 'chat-window' },
            React.createElement('div', { className: 'stack', style: { justifyContent: 'space-between' } },
              React.createElement('div', { className: 'stack' },
                React.createElement('h3', { style: { margin: 0 } }, activeChat ? `Chat with ${activeChat}` : 'Select or start a chat'),
              ),
            ),
            React.createElement('div', { className: 'chat-stream', ref: chatStreamRef },
              (messages || []).length === 0
                ? React.createElement('div', null, 'No messages yet.')
                : (messages || [])
                    .filter((m) => !activeChat || m.from === activeChat || m.to === activeChat || (profile && m.from === profile.username && m.to === activeChat))
                    .sort((a, b) => new Date(a.sentAt) - new Date(b.sentAt))
                    .map((m, idx) => {
                      const mine = profile && m.from === profile.username;
                      return React.createElement('div', { key: idx, className: `bubble ${mine ? 'me' : ''}` },
                        React.createElement('div', null, m.body),
                        React.createElement('div', { className: 'meta' }, new Date(m.sentAt).toLocaleString())
                      );
                    })
            ),
            React.createElement('form', { onSubmit: handleSend, className: 'composer' },
              React.createElement('input', {
                id: 'msg-body',
                value: messageForm.body,
                onChange: (e) => setField('messageForm', { ...messageForm, body: e.target.value }),
                placeholder: activeChat ? `Message ${activeChat}` : 'Type a message or invitation...',
                style: { flex: 1 },
                autoFocus: true,
                ref: messageInputRef,
              }),
              React.createElement('button', { type: 'submit' }, 'Send'),
            ),
          ),
        )
      );

      return (
        React.createElement('div', { className: 'main' },
            React.createElement('div', { className: 'topbar' },
              React.createElement('h1', null, 'Go Messaging App'),
              React.createElement('div', { className: 'stack' },
                profile && React.createElement('span', { className: 'pill' }, '@', profile.username),
                profile && React.createElement('button', { className: 'danger', onClick: handleLogout }, 'Logout'),
              ),
            ),
          React.createElement('div', { className: 'status' }, status),
          profile ? renderDashboard() : renderAuth(),
        )
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('app'));
    root.render(React.createElement(App));
  </script>
</body>
</html>
